from algebra import DGAlgebra, Element, Generator, Tensor, TensorGenerator,
from algebra import E0

class Simple_Strand(Generator):
    ''' Represents a generator of Strand Algebra. i.e 
    the bijections from S C [n] to T C [n]'''

    def __init__(self, parent, is_left, pairs):
        '''Specifies tangle that it takes it sign sequence from 
         parent Strand Algebra, and `pairs` as a list of pairs. Creates
         the tangle that it will use previous methods
         `pairs` is a tuple, that specifies the pairs
         if simple_strand connects 1 to 3, 3 to 4, it will contain
         ((1,3), (3,4))'''
        # parent here refers to the Algebra
        
        # S in petkova paper
        self.s = get_domain(pairs)
        # T in petkova paper
        self.t = get_range(pairs)
        
        #Check if S and T have the same size
        if len(self.s) != len(self.t):
            raise ValueError("Something is wrong -- S and T do not have the same size.")
            
        Generator.__init__(self,parent)
        self.p_tangle = parent.tangle # tangle that it takes its sign from 
        self.is_left == is_left
        
        if self.is_left == True:
            self.sign_seq = self.p_tangle.left_boundary
        else:
            self.sign_seq = self.p_tangle.right_boundary
    
        # Instantiate Base Tangle and strand: 
        self.tangle = Tangle(self.get_tangle_pairs())
        self.strands = Strands(self.tangle, self.get_tuple_strand(pairs))
           
    def __eq__(self, other):
        return self.parent == other.parent and self.strands == other.strands
    
    def __ne__ (self, other):
        return not (self == other)
        
    def __hash__(self):
        return hash((self.parent, self.strands))
    
    def __str__(self):
        return str(self.strands)
    
    def __repr__(self):
        return str(self)
    
    def get_tangle_pairs(self):
        ''' returns the dictionary object that is needed to make a new tangle.'''
        #1. generate pairs
        pairs = {}
        for coord,sign in self.sign_seq.items():
                
            np1 = (coord[0] - 0.5, coord[1])
            np2 = (coord[0] - 1, coord[1])
            if sign == -1:
                pairs.update({coord: np1, np1: np2})
            else:
                if sign != 1:
                    raise ValueError("Something is wrong with the sign")
                pairs.update({np2:np1, np1:coord})
                
        return pairs
        
    def get_tuple_strand(self,pairs): # cb an change
        ''' returns the tuple that is needed for strand object '''
        
        # quite necessary - will come back and remove if unncessary
        #if self.is_left true, then make bijections look like up/down then ---
        if self.is_left == True:
            right_half = tuple((k,k) for k in self.t)
            return tuple((pair, right_half))
        
        # if self.is_left False, then make bijections look like --- then up/down
        else:
            left_half = tuple((k,k) for k in self.s)
            return tuple((left_half,pairs))
        
#        # always up/down then horizontal_ CB to this laer 
#        right_half = tuple((k,k) for k in self.t)
#        return tuple((pair, right_half))
           
    def isIdempotent(self):
        return self.s == self.t

    def numCrossing(self): # cb and remove - already in strands class
        ''' Returns the number of crossings between moving strands
        either left_half or right_half depending on `left_half'''

        return self.strands.numCrossing(True) + self.strands.numCrossing(False)


class StrandAlgebra(DGAlgebra): #THE PARENT OF  STRAND Algebra
    '''Represents the strand algebra of a tangle T_i generated by 
     left or right sign sequence.'''
     
    def __init__(self, ring, tangle, is_left = True):
        '''Specifies the tangle T, and whether it takes the left or right sequence
        i.e if is_left == True, it is A(-dLT)
        if isleft == False, it is A(dRT) '''
        DGAlgebra__init__(self,ring)
        self.tangle = tangle
        self.is_left = is_left
    
    def __str__(self):
        if is_left == True:
            return "Strand Algebra over %s with taking sign sequence of \
                left boundary." %(str(self.tangle))
        else:
            return "Strand Algebra over %s with taking sign sequence of \
                right boundary." %(str(self.tangle))
    
    def __eq__(self,other):
        if not isinstance(other, StrandAlgebra):
            return False
        return self.tangle == other.tangle and self.is_left == other.is_left
    
    def __ne__(self,other):
        return not (self == other)
    
    def __hash__(self):
        return hash((self.tangle, self.is_left))
    
    
    def getStrandDiagram()
    